{
import "AutoinstStorage";
import "Mode";
import "Popup";
import "Stage";
import "Storage";
import "UI";
import "Wizard";
import "XML";
import "AutoinstLVM";
import "AutoinstRAID";

textdomain "installation";

integer				i = 0;   //temp counter
integer			  devices = 0;   //number of found free devices
list<string>          neededLVG   = [];  //The list of the LVG have to be created
list			     ltmp = [];  //temp list
map<string,integer>   freeDevices = $[]; //Device name of physikal drives with free spaces
map<string,string>	LVGSizes  = $[];
map<string,any>		  profile = $[];
string 			  fstab   = "";

Wizard::CreateDialog();

// **********************************************
// Function to select the devices for the VLG-s
// **********************************************
define boolean selectDevices()
``{
	term items = `VBox();

	foreach (string LVG, neededLVG, ``{
		term buttons = `VBox();
		foreach (string dev, integer tmp, freeDevices, ``{
			string tmp1 = "CHECK"+LVG + "#" + dev;
			string tmp2 = dev + " " + freeDevices[dev]:0/1024/1024/1024 + "GB";
			buttons = add( buttons, `CheckBox(`id(tmp1),`opt(`notify), tmp2, false));
		});
		term item = `Frame("Select the Devices for '"+LVG+"' Logical Volume Group",
				`HBox(
					buttons
				)
			);
		items = add( items, item );
	});
	Wizard::CreateDialog();
	items = add( items, `ButtonBox(
					`PushButton(`id(`cancel), _("Cancel")),
					`PushButton(`id(`ok),     _("OK"))
				 ));
	UI::OpenDialog(`opt(`decorated), items);

	while(true)
	{
		map event   = UI::WaitForEvent();
		any ret     = event["ID"]:nil;
		string sret = (string) event["ID"]:nil;
		y2milestone("Got event %1",ret);
		if(ret == `cancel) {
		   return false;
		}
		if(ret == `ok) {
			foreach ( string LVG, neededLVG, ``{
				foreach (string dev, integer tmp, freeDevices, ``{
					string wid = "CHECK"+LVG + "#" + dev;
					if( (boolean)UI::QueryWidget( `id(wid), `Value ) )
					{
						profile["partitioning"] = add( profile["partitioning"]:[],
						$[
							"device":dev,
							"use":"free",
							"partitions": [
								$[ "create":true,
								   "lvm_group":LVG,
				   				   "partition_id":142,
								   "size":"max"
								   ]
							]
						]);
					}
				});
			});
			return true;
		}
		if(  substring( sret, 0, 5) == "CHECK" )
		{
			ltmp = regexptokenize(sret,"CHECK(.*)#(.*)");
			foreach ( string LVG, neededLVG, ``{
					if( ltmp[0]:"" != LVG ){
						if( (boolean)UI::QueryWidget( `id(ret), `Value ) )
						{
							UI::ChangeWidget(`id("CHECK" + LVG + "#" + ltmp[1]:"" ), `Enabled, false);
						}
						else
						{
							UI::ChangeWidget(`id("CHECK" + LVG + "#" + ltmp[1]:"" ), `Enabled, true);
						}
					}
				});
		}
	}
}

// **********************************************
// Start the program.
// **********************************************
list args = WFM::Args();
if(size(args) == 0 )
{
	y2error("No argument for the partitioning");
	return nil;
}

//Read the proposed XML
profile = XML::XMLToYCPFile(args[0]:"");
y2milestone("Read Partitioning profile %1",profile);

//Get Memory Size in bytes
list memories  = (list)SCR::Read(.probe.memory);
integer memory = memories[0,"resource","phys_mem",0,"range"]:0;

if( profile["partitioning_defined"]:"no" != "yes" )
{
	i = 0;
	foreach(map drive, profile["partitioning"]:[], ``{
		y2milestone("getDrive %1",drive);
		if( drive["is_lvm_vg"]:false )
		{
			     ltmp = regexptokenize(drive["device"]:"","/dev/(.*)");
			string  n = ltmp[0]:"";
			neededLVG = add( neededLVG,n);
			string  s = drive["partitions",0,"size"]:"max";
			     ltmp = regexptokenize(s,"RAM\*(\d)");
			if( ltmp[0]:"" != "" )
			{
				s = tostring( tointeger(ltmp[0]:"")*memory ) + "B";
				profile["partitioning",i,"partitions",0,"size"] = s;
			}
			LVGSizes[n] = profile["partitioning",i,"partitions",0,"size"]:"0";
		}
		i = i+1;
	});
	y2milestone("Partitioning profile after parsing partition sizes %1",profile);

	//Read the device list
	map<string,map> d = Storage::GetTargetMap();
	y2milestone("target map %1",d);

	foreach (string name, map dev, d, ``{
		if( dev["type"]:nil != `CT_DISK )
		{
			continue;
		}
		y2milestone("disk %1", name );
		list<map> l = [];
		i = Storage::GetUnusedPartitionSlots(name, l );
		integer free = 0;
		foreach( map slot, l, ``{
			free = free + slot["region",1]:0 * dev["cyl_size"]:0 ;
		});
		if( free > 0 )
		{
			freeDevices[ name ] = free ;
			devices = devices + 1;
		}
	});
	y2milestone("freeDevices %1", freeDevices);
	if( devices == 0 )
	{
		//TODO check if there is enough disk pace to install the required product.
		Popup::Error("There is no free harddisk space on the system");
		return false;
	}
	else if( devices == 1 )
	{
		string  dev  = "";
		integer s    = 0;
		foreach (string d, integer t, freeDevices, ``{
			dev = d; s = freeDevices[d]:0;
		});
		y2milestone("Selecting the free device %1", dev);
		list <map> partitions  = [];
		y2milestone("Partitioning befor %1", profile["partitioning"]:[]);
		foreach ( string LVG, neededLVG, ``{
			partitions= add( partitions,
				$[ "create":true,
				   "lvm_group":LVG,
				   "partition_id":142,
				   "size":LVGSizes[LVG]:"max"
				   ] );
		});
		profile["partitioning"] = add( profile["partitioning"]:[],
				$[	"device":dev,
					"use":"free",
					"type":`CT_DISK,
					"partitions": partitions
				]);
		y2milestone("Partitioning after %1", profile["partitioning"]:[]);
	}
	else
	{
		if( !selectDevices() ) {
			return nil;
		}
	}

}
//Create fstab entries
i=0;
foreach(map drive, profile["partitioning"]:[], ``{
   if( drive["is_lvm_vg"]:false ) {
	fstab = fstab + drive["device"]:"" + "/" + profile["partitioning",i,"partitions",0,"lv_name"]:"" + "  "
		      + profile["partitioning",i,"partitions",0,"mount"]:"" + " "
		      + (string)profile["partitioning",i,"partitions",0,"filesystem"]:"" + " " 
		      + profile["partitioning",i,"partitions",0,"fstopt"]:"defaults" + " 0 0\n";
   }
   i = i+1;
});
y2milestone("fstab");
Stage::Set("initial");
Mode::SetMode("autoinstallation");
AutoinstStorage::Import(profile["partitioning"]:[]);
AutoinstStorage::Write();
if (AutoinstLVM::Init())
{
    AutoinstLVM::Write();
}
Storage::CommitChanges();
Storage::WriteFstab();
}
